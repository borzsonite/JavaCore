1. Создать поток можно 2мя способами
    - унаследоваться от класс Thread. При этом переопределяется run() в котором описывается то что выполняется в потоке. Поток запускается через вызов метода .start() выполняемого на объекте. myThread.run();
  -
2. Ключевое слово volatile используется в многопоточном приложении, когда к одной переменной возможен доступ из разных потоков, данное слово гарантирует, что разные потоки будут иметь дело с актуальным значением переменной и не возникнет ситуация при которой один поток будет иметь дело с закешированным значением переменной, а другой с актуальным значением. По сути использование этого слова запрещает кэширование переменной в кэше ядра. Тами образом обеспечивается синхронизация переменной для всех потоков.

3. Метод join() позволяет дождаться завершения выполнения одного потока до начала выполнения другого, например:
    thread1.start();
    thread1.join();
    thread2.start(); // начнет исполняться только после того как отработает thread1

4. Ключевое слово synchronized в сигнатуре метода означает что доступ к данному методу в один момент времени может иметь только один поток

5. У каждого объекта есть свой монитор, доступ к которому может иметь только один поток. В качестве монитора может выступать this или можно создать собственный lock, который может быть любым объектом, например Object lock = new Object();

6. Чтобы использовать лок его нужно передать в синхронизированный блок, вот так
        protected void addList1() {
            synchronized (lock1) {
                list1.add(random.nextInt(100));
            }
        }

7. Алгоритм создания пула потоков:
    1 создаем пул: ExecutorService executorService = Executors.newFixedThreadPool(2)
    2 принимаем задание: executorService.submit(Экземпляр runnable, c переопределенным методом run() в котором содержится задача)
    3 завершаем прием заданий и стартуем выполнение принятых: executorService.shutdown();
    4 устанавливаем время в течении которого основной поток будет ожидать выполнения заданий: executorService.awaitTermination(1, TimeUnit.DAYS); // здесь на один день

8. Все классы находящиеся в пакте java.util.concarency являются потокобезопасными, поэтому при использовании

9. Паттерн producer-consumer смысл в том что есть некий producer который выполняет какую-то работу, например заполняет очередь, заполняет до определенного предела, по достижении которого он приостанавливает свою работу. И есть потребитель который берет результат этой работы, например данные из очереди. После того очередь заполнилась продюсер останавливается и ждет, консьюмер берет элемет из очереди и она становиться не дозаполненной, тогда продюсер возобнавляет работу и дозаполняет очередь.

10. Метод wait() имеет смысл только в синхронизированом блоке и вызывается на объект который передаются параметром в synhronized(this) {}; например this