1. Создать поток можно 2мя способами
    - унаследоваться от класс Thread. При этом переопределяется run() в котором описывается то что выполняется в потоке. Поток запускается через вызов метода .start() выполняемого на объекте. myThread.run();
  - передать в конструктор класса Thread экземпляр реализующий интерфейс Runnable

2. Ключевое слово volatile используется в многопоточном приложении, когда к одной переменной возможен доступ из разных потоков, данное слово гарантирует, что разные потоки будут иметь дело с актуальным значением переменной и не возникнет ситуация при которой один поток будет иметь дело с закешированным значением переменной, а другой с актуальным значением. По сути использование этого слова запрещает кэширование переменной в кэше ядра. Тами образом обеспечивается синхронизация переменной для всех потоков.

3. Метод join() позволяет дождаться завершения выполнения одного потока до начала выполнения другого, например:
    thread1.start();
    thread1.join();
    thread2.start(); // начнет исполняться только после того как отработает thread1

4. Ключевое слово synchronized в сигнатуре метода означает что доступ к данному методу в один момент времени может иметь только один поток

5. У каждого объекта есть свой монитор, доступ к которому может иметь только один поток. В качестве монитора может выступать this или можно создать собственный lock, который может быть любым объектом, например Object lock = new Object();

6. Чтобы использовать лок его нужно передать в синхронизированный блок, вот так
        protected void addList1() {
            synchronized (lock1) {
                list1.add(random.nextInt(100));
            }
        }

7. Алгоритм создания пула потоков:
    1 создаем пул: ExecutorService executorService = Executors.newFixedThreadPool(2)
    2 принимаем задание: executorService.submit(Экземпляр runnable, c переопределенным методом run() в котором содержится задача)
    3 завершаем прием заданий и стартуем выполнение принятых: executorService.shutdown();
    4 устанавливаем время в течении которого основной поток будет ожидать выполнения заданий: executorService.awaitTermination(1, TimeUnit.DAYS); // здесь на один день

8. Все классы находящиеся в пакте java.util.concarency являются потокобезопасными, поэтому при использовании

9. Паттерн producer-consumer смысл в том что есть некий producer который выполняет какую-то работу, например заполняет очередь, заполняет до определенного предела, по достижении которого он приостанавливает свою работу. И есть потребитель который берет результат этой работы, например данные из очереди. После того очередь заполнилась продюсер останавливается и ждет, консьюмер берет элемет из очереди и она становиться не дозаполненной, тогда продюсер возобнавляет работу и дозаполняет очередь.

10. Метод wait() имеет смысл только в синхронизированом блоке и вызывается на объекте который передаются параметром в synhronized(this) {this.wait()}; например this

11. Метод wait() освобождает монитор и останавливает выполнение потока (ждет вызова метода notify())

12. Метод notify() в  отличии от wait() не освобождает монитор

13. Для возобновления выполнения потока в котором был вызван метод wait() необходимо 2 условия: 1-е должен быть освобожден и захвачен потоком монитор; 2- должен быть вызван метод notify()

14. При вызове методов notify() и wait() необходимо или явно указвать объект (монитор) на котором присходит синхронизация (lock.wait()  lock.notify()), либо если явно не указывать монитор помнить что в этом случае методы вызываются на this (this.wait()  this.notify())

15. Объект монитора должен быть константой

16. notify() обычно вызывается в конце synchronized блока, потому что notify() не освобождает монитор и чтобы он освободился программа должна выйти из блока

17. Объект CountDownLatch имеет метод countDown() и метод await(). Последний ждет сколько раз выполнится countDown() прежде чем продолжить выполнение кода. Количество выполнений задается при создании объекта CountDownLatch.

18. Класс ReentrantLock служит для синхронизации методов аналогично тому, как действует слово synhronized. Можно создать объект данного класса и вызывать на нем методы lock() unlock(). Например:
        public void thirstThread() {
            lock.lock();
            increment();
            lock.unlock();
        }

        public void secondThread() {
            lock.lock();
            increment();
            lock.unlock();
        }
 при этом метод lock() залочивает метод, так что другие потоки не могут получить к нему доступ, unlock() разлочивает.

19. Класс Семафор используется в случае доступа нескольких потоков к одному ресурсу. Он позваляет делить один ресурс между несколькими потоками.

//////////////////////////////////ВОПРОСЫ//////////////////////////////////

1. Как можно создать поток?
2. Для чего и когда используется ключевое слово volatile?  Что происходит при его использовании?
3. Для чего нужен метод join(), на каком объекте он вызывается?
4. Что означает ключевое слово synchronized в сигнатуре метода?
5. Что существует у каждого объекта? Сколько потоков может доступ к данной сущности в один момент времени? Что может выступать в качестве данной сущности?
6. Каким образом следует использовать монитор в синхронизированном блоке?
7. Каков алгоритм создания и применения пула потоков?
8. Что отличает классы находящиеся в пакете java.util.concurrency?
9. В чем смыл использования паттерна producer-consumer?
10. Где имеет смысл применение метода wait()?
11. Что делает и чего ожидает метод wait()?
12. В чем отличие  метода notify() от wait()?
13. Какие необходимые условия для возобновления потока остановленного методом wait()?
14. Что необходимо указывать при вызове методов notify() и wait(), что произойдет если это не указывать?
15. Каким должен быть объект монитора?
16. Когда обычно вызывается notify() и почему?
17. Какие методы есть у объекта CountDownLatch и что они делают?