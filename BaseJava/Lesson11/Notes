1. Создать поток можно 2мя способами
    - унаследоваться от класс Thread. При этом переопределяется run() в котором описывается то что выполняется в потоке. Поток запускается через вызов метода .start() выполняемого на объекте. myThread.run();
  -
2. Ключевое слово volatile используется в многопоточном приложении, когда к одной переменной возможен доступ из разных потоков, данное слово гарантирует, что разные потоки будут иметь дело с актуальным значением переменной и не возникнет ситуация при которой один поток будет иметь дело с закешированным значением переменной, а другой с актуальным значением. По сути использование этого слова запрещает кэширование переменной в кэше ядра. Тами образом обеспечивается синхронизация переменной для всех потоков.

3. Метод join() позволяет дождаться завершения выполнения одного потока до начала выполнения другого, например:
    thread1.start();
    thread1.join();
    thread2.start(); // начнет исполняться только после того как отработает thread1

4. Ключевое слово synchronized в сигнатуре метода означает что доступ к данному методу в один момент времени может иметь только один поток

5. У каждого объекта есть свой монитор, доступ к которому может иметь только один поток. В качестве монитора может выступать this или можно создать собственный lock, который может быть любым объектом, например Object lock = new Object();

6. Чтобы использовать лок его нужно передать в синхронизированный блок, вот так
        protected void addList1() {
            synchronized (lock1) {
                list1.add(random.nextInt(100));
            }
        }

7. Алгоритм создания пула потоков:
    1 создаем пул: ExecutorService executorService = Executors.newFixedThreadPool(2)
    2 принимаем задание: executorService.submit(Экземпляр runnable, c переопределенным методом run() в котором содержится задача)
    3 завершаем прием заданий и стартуем выполнение принятых: executorService.shutdown();
    4 устанавливаем время в течении которого основной поток будет ожидать выполнения заданий: executorService.awaitTermination(1, TimeUnit.DAYS); // здесь на один день

8. Все классы находящиеся в пакте java.util.concarency являются потокобезопасными, поэтому при использовании

9. Паттерн producer-consumer смысл в том что есть некий producer который выполняет какую-то работу, например заполняет очередь, заполняет до определенного предела, по достижении которого он приостанавливает свою работу. И есть потребитель который берет результат этой работы, например данные из очереди. После того очередь заполнилась продюсер останавливается и ждет, консьюмер берет элемет из очереди и она становиться не дозаполненной, тогда продюсер возобнавляет работу и дозаполняет очередь.

10. Метод wait() имеет смысл только в синхронизированом блоке и вызывается на объект который передаются параметром в synhronized(this) {}; например this

11. Метод wait() освобождает монитор и останавливает выполнение потока (ждет вызова метода notify())

12. Метод notify() в  отличии от wait() не освобождает монитор

13. Для возобновления выполнения потока в котором был вызван метод wait() необходимо 2 условия: 1-е должен быть освобожден и захвачен потоком монитор; 2- должен быть вызван метод notify()

14. При вызове методов notify() и wait() необходимо или явно указвать объект (монитор) на котором присходит синхронизация (lock.wait()  lock.notify()), либо если явно не указывать монитор помнить что в этом случае методы вызываются на this (this.wait()  this.notify())

15. Объект монитора должен быть константой

16. notify() обычно вызывается в конце synchronized блока, потому что notify() не освобождает монитор и чтобы он освободился программа должна выйти из блока

17. Объект CountDownLatch имеет метод countDown() и метод await(). Последний ждет сколько раз выполнится countDown() прежде чем продолжить выполнение кода. Количество выполнений задается при создании объекта CountDownLatch.