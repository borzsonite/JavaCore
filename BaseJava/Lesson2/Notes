1. Структура объекта типа Integer: Метаданые (Class - указатель на сведения о классе (java.lang.Integer), флаги (flags), сведения о синхронизации объекта (Lock) + значение типа int. Метаданыне занимают 96 бит, значение 32 бита.

2. Структура объекта типа массив аналогична, только в метаданных содержится сведения о размере массива.

3. При запуске программы для каждого потока выделятся отдельны  стэк

4. В стеке хранятся локальные переменные, значения примитивных типов, параметры методов, адреса возврата

5. В метаспейс храняться загруженные классы + константы

6. Переменную следует объявлять перед использованием

7. метод .getClass() возвращает класс от которого был порожден объект

8. Класс Class является метаклассом для всех классов Java. Когда JVM загружает файл .class, который описывает некоторый тип, в памяти создается объект класса Class, который будет хранить это описание.

9. Кроме полей и методов, статическими могут быть инициализаторы. Они также называются инициализаторами класса, в отличие от инициализаторов объекта, рассматривавшихся ранее. Их код выполняется один раз во время загрузки класса в память виртуальной машины. Их запись начинается с модификатора static:

   class Human {
      static {
         System.out.println("Class loaded");
      }
   }

10. нельзя использовать поле в инициализаторах других полей или в инициализаторах класса до того, как это поле объявлено. Это правило распространяется только на обращения к полям по простому имени. Если использовать составное имя, то обращаться к полю можно будет раньше (выше в тексте программы), чем оно будет объявлено: (можно также использовать this, напр. this.var)

11. К статическому контексту относят статические методы, статические инициализаторы, инициализаторы статических полей. Все остальные части кода имеют динамический контекст.

12. При выполнении кода в динамическом контексте всегда есть объект, с которым идет работа в данный момент. Например, для динамического метода это объект, у которого он был вызван, и так далее. Напротив, со статическим контекстом ассоциированных объектов нет. А раз нет ассоциированных объектов, то и пользоваться динамическими конструкциями нельзя. Можно только ссылаться на статические поля и вызывать статические методы. Либо обращаться к объектам через ссылки на них, полученные в результате вызова конструктора или в качестве аргумента метода и т.п.

13. То есть внутри методов слово this возвращает ссылку на объект, у которого этот метод вызван. Оно необходимо, если нужно передать аргумент, равный ссылке на данный объект, в какой-нибудь метод.

14. слово this применяется в конструкторах для явного вызова в первой строке другого конструктора этого же класса. Там же может применяться и слово super, только уже для обращения к конструктору родительского класса.

15. Другие применения слова super также связаны с обращением к родительскому классу объекта. Например, оно может потребоваться в случае переопределения (overriding) родительского метода. Переопределением называют объявление метода, сигнатура которого совпадает с одним из методов родительского класса.
class Parent {
   public int getValue() {
      return 5;
   }
}

class Child extends Parent {

   // переопределение метода
   public int getValue() {
      // обращение к методу родителя
      return super.getValue()+1;
   }

   public static void main(String s[]) {
      Child c = new Child();
      System.out.println(c.getValue());
   }
}
Результатом работы программы будет значение 6.

16. Поскольку ключевые слова this и super требуют наличия ассоциированного объекта, т.е. динамического контекста, использование их в статическом контексте запрещено.

17. класс не может быть одновременно abstract и final. Это же верно и для методов. Кроме того, абстрактный метод не может быть private, native, static.

18. Сам класс может без ограничений пользоваться своими абстрактными методами.

    abstract class Test {
       public abstract int getX();
       public abstract int getY();
       public double getLength() {
          return Math.sqrt(getX()*getX()+
                           getY()*getY());
       }
    }
 Это корректно, поскольку метод getLength() может быть вызван только у объекта. Объект может быть порожден только от не абстрактного класса, который является наследником от Test, и должен был реализовать все абстрактные методы.

 19. Интерфейс может быть объявлен как public и тогда он будет доступен для общего использования, либо модификатор доступа может не указываться, в этом случае интерфейс доступен только для типов своего пакета.

 
20. Все поля интерфейса  public final static. Эти модификаторы указывать не неужно. Поскольку поля объявляются финальными, необходимо их сразу инициализировать:

  public interface Directions {
       int RIGHT=1;
       int LEFT=2;
       int UP=3;
       int DOWN=4;
}

21. Все методы интерфейса являются public abstract и эти модификаторы также необязательны.

    public interface Moveable {
       void moveRight();
       void moveLeft();
       void moveUp();
       void moveDown();
    }

22.  Модификатор abstract для интерфейса не требуется, поскольку все интерфейсы являются абстрактными.

23. Интерфейсы могут наследоваться от других интерфейсов, через extends

24. Если из разных источников наследуются методы с одинаковой сигнатурой, то достаточно один раз описать реализацию и она будет применяться для всех этих методов. Однако если у них различное возвращаемое значение, то возникает конфликт:

    interface A {
      int getValue();
    }

    interface B {
      double getValue();
    }
    Если попытаться объявить класс, реализующий оба эти интерфейса, то возникнет ошибка компиляции. В классе оказывается два разных метода с одинаковой сигнатурой, что является неразрешимым конфликтом. Это единственное ограничение на набор интерфейсов, которые может реализовывать класс.

25. Подобный конфликт с полями-константами не столь критичен:

    interface A {
      int value=3;
    }
    interface B {
      double value=5.4;
    }
    class C implements A, B {
      public static void main(String s[]) {
        C c = new C();
        // System.out.println(c.value); - ошибка!
        System.out.println(((A)c).value);
        System.out.println(((B)c).value);
      }
    }
    Как видно из примера, обращаться к такому полю через сам класс нельзя, компилятор не сможет понять, какое из двух полей нужно использовать. Но можно с помощью явного приведения сослаться на одно из них.

26. Наследники могут объявлять поля с именами, совпадающими с родительскими полями. Такие объявления называют скрывающими. При этом объекты будут содержать оба значения, а компилятор будет каждый раз определять, с каким из них надо работать.

27. У класса наследника переопределяемый метод, должен иметь такой же или более открытый модификатор доступа.

28. Основная цель абстрактных методов – описать в родительском классе как можно больше общих свойств наследников, пусть даже и в виде заголовков методов без реализации.

29. Каков будет результат следующих строк?

    Child c = new Child();
    System.out.println(c.a);
    Parent p = c;
    System.out.println(p.a);
    Нужно вспомнить, как компилятор обрабатывает обращения к статическим полям через ссылочные значения. Неважно, на какой объект указывает ссылка. Более того, она может быть даже равна null. Все определяется типом ссылки.

    Поэтому рассматриваемый пример эквивалентен:

    System.out.println(Child.a)
    System.out.println(Parent.a)
    А его результат сомнений уже не вызывает:

    3
    2

30. Static — модификатор, применяемый к полю, блоку, методу или внутреннему классу. Данный модификатор указывает на  привязку субъекта  к текущему классу.

31. Статическим классом может быть только внутренний класс.

32. При обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной.

34. Вы НЕ можете получить доступ к НЕ статическим членам класса, внутри статического контекста, как вариант, метода или блока.

35. В отличие от локальных переменных, статические поля и методы НЕ потокобезопасны (Thread-safe) в Java.  Учитывая что каждый экземпляр класса имеет одну и ту же копию статической переменной, то такая переменная нуждается в защите — «залочивании» классом.

36. Вы НЕ можете переопределять (Override) статические методы. Если вы объявите такой же метод в классе-наследнике (subclass), т.е. метод с таким же именем и сигнатурой, вы лишь «спрячете» метод суперкласса (superclass) вместо переопределения.

37. При обращении к статическому методу, который объявлен как в родительском, так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной.

38. Объявить статическим также можно и класс, за исключением классов верхнего уровня. Такие классы известны как «вложенные статические классы» (nested static class). Они бывают полезными для представления улучшенных связей.

39. Модификатор static также может быть объявлен в статичном блоке, более известным как «Статический блок инициализации» (Static initializer block), который будет выполнен во время загрузки класса. Если вы не объявите такой блок, то Java соберёт все статические поля в один список и выполнит его во время загрузки класса.

40. Полезно знать, что статические методы связываются во время компиляции, в отличие от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте. Следовательно, статические методы не могут быть переопределены в Java, т.к. полиморфизм во время выполнения не распространяется на них.

41. Важным свойством статического блока является инициализация. Статические поля или переменные инициализируются после загрузки класса в память. Порядок инициализации сверху вниз, в том же порядке, в каком они описаны в исходном файле Java класса.

42. Во время сериализации, также как и transient переменные, статические поля не сериализуются. Действительно, если сохранить любые данные в статическом поле, то после десериализации новый объект будет содержать его первичное (по-умолчанию) значение, например, если статическим полем была переменная типа int, то её значение после десериализации будет равно нулю, если типа float – 0.0, если типа Object – null.

43. Метод equals() может быть переопределен любым способом (например, всегда возвращать false, или, наоборот, true ) – компилятор, конечно же, не будет проводить анализ реализации и давать рекомендации. Однако существуют соглашения, которые необходимо соблюдать, чтобы программа имела предсказуемое поведение, в том числе и с точки зрения других программистов:

   -  рефлексивность: для любой объектной ссылки x, отличной от null, вызов x.equals(x) возвращает true ;
   -  симметричность: для любых объектных ссылок x и y, вызов x.equals(y) возвращает true только в том случае, если вызов y.equals(x) возвращает true ;
   -  транзитивность: для любых объектных ссылок x, y и z, если x.equals(y) возвращает true и y.equals(z) возвращает true, то вызов x.equals(z) должен вернуть true ;
   -  непротиворечивость: для любых объектных ссылок x и y многократные последовательные вызовы x.equals(y) возвращают одно и то же значение (либо всегда true, либо всегда false );
   -  для любой не равной null объектной ссылки x вызов x.equals(null) должен вернуть значение false.

44. В запущенной программе Java каждому классу соответствует объект типа Class. Этот объект содержит информацию, необходимую для описания класса – поля, методы и т.д.

45. Для каждого примитивного типа Java существует свой класс-обертка . Такой класс является неизменяемым (если необходим объект, хранящий другое значение, его нужно создать заново), к тому же имеет атрибут final – от него нельзя наследовать класс.

46. При этом классы-обертки числовых типов Byte, Short, Integer, Long, Float, Double наследуются от одного класса – Number

47. Основные методы, используемые для модификации StringBuffer, это:
    public StringBuffer append(String str) – добавляет переданную строку str в буфер;
    public StringBuffer insert(int offset, String str) – вставка строки, начиная с позиции offset (пропустив offset символов).

48. Еще один важный момент, связанный с этими методами, – они возвращают сам объект, у которого вызываются. Благодаря этому, возможно их использование в цепочке.

49. Если класс объявляется абстрактным это означает лишь то, что он не может быть инстанцирован

50. Абстрактный класс может не иметь абстрактных методов

51. Класс экстендящий абстрактный должен либо имплементить все абстрактные методы либо тоже быть обявлен абстрактным.

52. Класс реализующий интерфейс должен либо реализовать все абстрактные методы либо объявлен абстрактным.

53. Итак, наследники могут объявлять поля с именами, совпадающими с родительскими полями. Такие объявления называют скрывающими. При этом объекты будут содержать оба значения, а компилятор будет каждый раз определять, с каким из них надо работать.

54. При наличии одинаковых переменных в родителе и потомке, то какая переменая будет вызвана определяется типом ссылки
    Parent variable = new Child(); // сылка имеет тип Parent значит обращение будет к переменной из родителя.

55. При наличии двух одинаковых  НЕ СТАТИЧЕСКИХ методов в родителе и потомке, то какой метод будет вызван, определяется НЕ типом ссылки, а тем на какой объект она ссылается. Даже если ссылка типа Parent, но ссылается на потомка, то будет вызван метод потомка. Походу это связано с поздним связыванием, и это приводит к полиморфизму.

56. При наличии двух одинаковых СТАТИЧЕСКИХ методов в родителе и потомке, то какой метод будет вызван определяется ТИПОМ ссылки, а НЕ тем на какой объект она ссылается. Если ссылка типа Parent, но ссылается на потомка, все равно будет вызван метод РОДИТЕЛЯ. Это справедливо и для СТАТИЧЕСКИХ переменных.

57. Cтатические методы, подобно статическим полям, принадлежат классу и появление наследников на них не сказывается.
    Статические методы не могут перекрывать обычные, и наоборот.

58. Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов

59. Суть шаблонного метода в том, что нам нужно реализовать практически одинаковый код, с незначительными отличиями. Для этого берется абстрактный класс в котором прописывается реализация которая будет одинакова в обоих случаях, различая будут реализовываться за счет абстрактных методов, которые определяются в этом же абстрактном классе, но реализуются в наследниках.

60. 1. Паттерн шаблоный метод используется когда нужно переопределить в наследниках какую-то общую логику заложенную в базовом (абстрактном) классе. В базовом классе может содержаться 3 вида методов: 1 - абстрактные которые должны быть определены в классах-наследниках. 2. - методы содержащие общую для всех наследников реализацию, которые, в свою очередь, тоже могут переопределсятся (но могут реализовываться без изменений), 3 - хуки обычные методы без кода, служат для вклинивания в шаблонный метод.

2. Насколько я понял в классическом варианте, реализация шаблонного метода выглядит так:

abstract class SomeClass {

    void templateMethod() { // шаблонный метод
        someMethod1(); // реализуются в классах наследниках
        someMethod2();
        someMethod3();
        method4();
    }

    abstract method4(); // переопределяется в классах наследниках
}

во всяком случае такие варианты я видел тут:https://www.codeflow.site/ru/article/java-template-method-pattern
тут: https://metanit.com/sharp/patterns/3.4.php
тут: https://refactoring.guru/ru/design-patterns/template-method/java/example

Но видно я чего-то недопонял, потому что в таком варианте во всех наследниках приходится прописывать какую-то реализацию методов, вызываемых в .templateMethod(), что приведет к дублированию кода. В чем профит такого подхода непонятно. В моем варианте домашки, шаблоннными, походу, являются методы .clear(), .update(), .delete(), .save(), get(). Т.е. методы которые служат шаблонами для реализации в наследниках, По-сути это просто наследование реализации из базового абстрактного класса + переопределение одного абстрактного метода .getIndex(). Можно ли назвать это применением патерна "шаблонный метод" я хз.

3. Шаблонным метод называется потому, что он задает шаблон для алгоритма,  который затем реализуется в классах-наследниках

4. Если не использовать данный паттерн, это приведет к дублированию кода.

///////////////////////////////ВОПРОСЫ///////////////////////////////
1. Из каких секций состоит объект Integer?
2. Из каких секций состоит объект массива?
3. Что выделяется для каждого потока при запуске программы?
4. что хранится в стеке?
5. что хранится в метаспейс?
6. Когда следует объявлять переменную?
7. Что возвращает .getClass()?
8. Чем является Class в Java, что происходит когда JVM загружает файл .class, который описывает некоторый тип?
9. Что такое статический инициализатор (СИ)? Как выполняется код из СИ?
10. До какого момента нельзя использовать поле? Какие есть исключения?
11. Что относится к статическому контексту?
12. Что можно и что нельзя делать из статического контекста?
13. Что возвращает this внутри метода?
14. Для чего служит this/super внутри конструктора?
15. Когда еще используется super?
16. Можно ли использовать this/super в статическом контексте?
17. Может ли абстрактный класс или метод быть final?
18. Можно ли внутри абстрактного класса использовать его абстрактные поля и методы?
19. Какие модификаторы доступа могут быть у интерфейса?
20. Какими являются поля интерфейса? Что необходимо сделать при объявлении полей интерфейса?
21. Какими являются методы интерфейса?
22. Нужно ли указывать для интерфейса abstract почему?
23. Могут ли интерфейсы наследоваться от др. интерфейсов?
24. Какое ограничение существует при реализации нескольких интерфейсов?
25. Как можно обратиться ко полю интерфейса, если класс реализует два интерфейса в котором объявлено одно и то же поле?
26. Какое объявление переменной называют скрывающим? Что будут содержать при этом объекты? Что будет определять компилятор?
27. Каким должен быть модификатор доступа у метода класса наследника?
28. Какая основная цель абстрактного класса?
29. При обращении к статическом полю чем определяется его выбор в родителе или наследнике?
30. К чему применяется модификатор static?
31. Может ли класс быть статическим?
32. Если статический метод объявлен и в базовом и в дочернем классе исходя из чего будет определятся версия вызываемого метода?
34. Можно ли получить доступ к нестатическим членам из статического контекста?
35. В чем отличае локальных переменных от статических?
36. Можно ли переопределять статические методы? что будет если переопределить статический метод в наследнике?
37. Исходя из чего вызывается статический метод объявленый в и в родителе и в наследнике?
38. Для чего могут быть полезны статические классы?
39. Когда и как выполняется статический блок инициализации?
40. когда связываются статические методы, а когда динамические?
42. Что происходит со статическими полями при сериализации?
43. Пять принципов относительно .equals()
44. Что содержить объект типа Class?
45. Что существует для каждого примитивного типа в Java?
46. От какого класса наследуются обертки?
47. Основные методы StringBuffer?
48. Что возвращают методы StringBuffer и как это используется?
49. Что означает объявление класса абстрактным?
50. Можел ли абстрактный класс быть без абстрактных методов?
51. Какие требования к классу наследующемуся от абстрактного?
52. Какие требования к классу реализующему интерфейс?
53. Могут ли в наследниках быть поля совпадающией с полями родителя? Что происходит при этом?
54. Чем определяется выбор переменной при наличии одинаковых полей в родителе и потомке?
55. Чем определяется вызов двух одинаковых нестатических методов в родителе и потомке?
56. Чем определяется вызов двух одинаковых статических методов в родителе и потомке?
57. Как сказывается наличие наследников на статических полях и методах? Могут ли статические классы перекрывать обычные методы и наоборот?

58. Возможен ли полиморфизм для статических методов, почему так?
59. В чем суть шаблонного метода.
60. Вопросы из ДЗ_3
    - для чего используется паттерн Шаблонный метод?
    - какие методы в твоем коде являются шаблонными?
    - почему он называется шаблонным?
    - Что будет с кодом, если не использовать данный паттерн?