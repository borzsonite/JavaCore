1. Структура объекта тип Integer: Метаданые (Class - указатель на сведения о классе (java.lang.Integer), флаги (flags), сведения о синхронизации объекта (Lock) + значение типа int. Метаданыне занимают 96 бит, значение 32 бита.

2. Структура объекта типа массив аналогична, только в метаданных содержится сведения о размере массива.

3. При запуске программы для каждого потока выделятся отдельны  стэк

4. В стеке хранятся локальные переменные, значения примитивных типов, параметры методов, адреса возврата

5. В метаспейс храняться загруженные классы + константы

6. Переменную следует объявлять перед использованием

7. метод .getClass() возвращает класс от которого был порожден объект

8. Класс Class является метаклассом для всех классов Java. Когда JVM загружает файл .class, который описывает некоторый тип, в памяти создается объект класса Class, который будет хранить это описание.

9. Кроме полей и методов, статическими могут быть инициализаторы. Они также называются инициализаторами класса, в отличие от инициализаторов объекта, рассматривавшихся ранее. Их код выполняется один раз во время загрузки класса в память виртуальной машины. Их запись начинается с модификатора static:

   class Human {
      static {
         System.out.println("Class loaded");
      }
   }

10. нельзя использовать поле в инициализаторах других полей или в инициализаторах класса до того, как это поле объявлено. Это правило распространяется только на обращения к полям по простому имени. Если использовать составное имя, то обращаться к полю можно будет раньше (выше в тексте программы), чем оно будет объявлено: (можно также использовать this, напр. this.var)

11. К статическому контексту относят статические методы, статические инициализаторы, инициализаторы статических полей. Все остальные части кода имеют динамический контекст.

12. При выполнении кода в динамическом контексте всегда есть объект, с которым идет работа в данный момент. Например, для динамического метода это объект, у которого он был вызван, и так далее. Напротив, со статическим контекстом ассоциированных объектов нет. А раз нет ассоциированных объектов, то и пользоваться динамическими конструкциями нельзя. Можно только ссылаться на статические поля и вызывать статические методы. Либо обращаться к объектам через ссылки на них, полученные в результате вызова конструктора или в качестве аргумента метода и т.п.

13. То есть внутри методов слово this возвращает ссылку на объект, у которого этот метод вызван. Оно необходимо, если нужно передать аргумент, равный ссылке на данный объект, в какой-нибудь метод.

14. слово this применяется в конструкторах для явного вызова в первой строке другого конструктора этого же класса. Там же может применяться и слово super, только уже для обращения к конструктору родительского класса.

15. Другие применения слова super также связаны с обращением к родительскому классу объекта. Например, оно может потребоваться в случае переопределения (overriding) родительского метода. Переопределением называют объявление метода, сигнатура которого совпадает с одним из методов родительского класса.
class Parent {
   public int getValue() {
      return 5;
   }
}

class Child extends Parent {

   // переопределение метода
   public int getValue() {
      // обращение к методу родителя
      return super.getValue()+1;
   }

   public static void main(String s[]) {
      Child c = new Child();
      System.out.println(c.getValue());
   }
}
Результатом работы программы будет значение 6.

16. Поскольку ключевые слова this и super требуют наличия ассоциированного объекта, т.е. динамического контекста, использование их в статическом контексте запрещено.



