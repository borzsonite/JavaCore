1. Класс Collections
Класс Collections является классом-утилитой и содержит несколько вспомогательных методов для работы с классами, обеспечивающими различные интерфейсы коллекций. Например, для сортировки элементов списков, для поиска элементов в упорядоченных коллекциях и т.д. Но, пожалуй, наиболее важным свойством этого класса является возможность получения синхронизированных вариантов классов-коллекций. Например, для получения синхронизированного варианта Map можно использовать следующий подход:

HashMap hm = new HashMap();
Map syncMap = Collections.synchronizedMap(hm);

2. Инициализация статических полей в месте объявления и статические блоки выполняются в порядке их объявления в классе. Инициализация происходит во время загрузки класса.

3. Чем отличается ArrayList от LinkedList? ArrayList это список, реализованный на основе массива, а LinkedList — это классический связный список, основанный на объектах с ссылками между ними. Преимущества ArrayList: в возможности доступа к произвольному элементу по индексу за постоянное время (так как это массив), минимум накладных расходов при хранении такого списка, вставка в конец списка в среднем производится так же за постоянное время. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize().

4. Недостатки ArrayList проявляются при вставке/удалении элемента в середине списка — это взывает перезапись всех элементов размещенных «правее» в списке на одну позицию влево, кроме того, при удалении элементов размер массива не уменьшается, до явного вызова метода trimToSize().

5. В целом же, LinkedList в абсолютных величинах проигрывает ArrayList и по потребляемой памяти и по скорости выполнения операций. LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или в случаях, когда необходимо гарантированное время добавления элемента в список.

6. В случаях, когда в исходный список (ArrayList) необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод addAll(index, Collection). И хотя, данный метод скорее всего вызовет System.arraycopy() три раза, в итоге это будет гораздо быстрее поэлементного добавления.

7. Local variable — это переменная, которая определена внутри метода и существует вплоть до того момента, пока выполняется этот метод. Как только выполнение закончится, локальная переменная перестанет существовать.

8. Instance Variable — переменная, которая определена внутри класса, и она существует вплоть до того момента, пока существует объект.

9. Модификаторы доступа — это инструмент, при помощи которого можно настроить доступ к классам, методам и переменным.

10. Сигнатура метода это его название + параметры

11. Перегрузка метода
одно и то же имя метода;
разные аргументы;
может быть разный возвращаемый тип.

12. Какая разница между абстрактным классом и интерфейсом?
    Абстрактный класс:
    абстрактные классы имеют дефолтный конструктор; он вызывается каждый раз, когда создается предок этого абстрактного класса;
    содержит как абстрактные методы, так и не абстрактные. По большому счету может и не содержать абстрактных методов, но все равно быть абстрактным классом;
    класс, который наследуется от абстрактного, должен реализовать только абстрактные методы;
    абстрактный класс может содержать Instance Variable(смотри вопрос №5).
    Интерфейс:
    не имеет никакого конструктора и не может быть инициализирован;
    только абстрактные методы должны быть добавлены (не считая default methods);
    классы, реализующие интерфейс, должны реализовать все методы (не считая default methods);

13. Mutable называются объекты, чьи состояния и переменные можно изменить после создания. Например такие классы, как StringBuilder, StringBuffer.

14. Чтоб написать immutable неизменяемый класс, нужно следовать простым пунктам:
    сделать класс финальным.
    сделать все поля приватными и создать только геттеры к ним. Сеттеры, разумеется, не нужно.
    Сделать все mutable поля final, чтобы установить значение можно было только один раз.
    инициализировать все поля через конструктор, выполняя глубокое копирование (то есть, копируя и сам объект, и его переменные, и переменные переменных, и так далее)
    клонировать объекты mutable переменных в геттерах, чтобы возвращать только копии значений, а не ссылки на актуальные объекты.

15. Если нужно дабавить или удалить одну коллекцию в другую есть методы addAll() removeAll()

16. collection.toString() // вывести коллекцию

17. Во время итерирования по коллекции, к ее элементам нельзя применять метод remove();

    public SortedArrayStorageTest() {
        super(new SortedArrayStorage());
    }
}


7. размещай конструкторы в классе в порядке, зависящем от принимаемых ими числа аргументов: от меньшего к большему

8. модификаторов public у полей быть не должно

9. размещай Override-методы в самом конце класса

10.