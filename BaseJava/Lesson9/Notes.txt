1. InputStream , OutputStream базовые абстрактные классы описывающие операции ввода ввыода байт. Содержат метдоы read() , write()

2. Классы-реализации потоков данных
Классы ByteArrayInputStream и ByteArrayOutputStream
Самый естественный и простой источник, откуда можно считывать байты, – это, конечно, массив байт. Класс ByteArrayInputStream представляет поток, считывающий данные из массива байт. Этот класс имеет конструктор, которому в качестве параметра передается массив byte[]. Соответственно, при вызове методов read() возвращаемые данные будут браться именно из этого массива.

3. Механизм чтения записи у потоков следующий: 1. При создании нового  объекта потока ему в конструктор передается источник, либо пункт назначения. Далее на у объекта потока вызывается метод read()/ write() которым считываются или записываются данные.

4. Патерн стратегия: Есть некий интрефейс, описывающий абстрактную стратегию и есть конкретные классы реализующие эту стратегию. Например, интерфейс Activity c методом void activity() и классы реализующие разные виды активности: Класс Run переопределяющий метод activity(), класс Sleep, класс Study etc... Есть также класс, который может реализовытвть разные виды активности, например, Human, у него есть поле типа Activity, setter для этого поля, который устанавливает необходимую стратегию и, собственно, метод реализующий выбранную стратегию.

5. С точки зрения используемой памяти, статические переменные размещаются в специальном пуле в памяти JVM, называемом Metaspace

6. Хотя у конструктора и не указывается возвращаемый тип, но он все же неявно возвращает тип создаваемого объекта

7. Обратите внимание на способ и порядок размещения конструкторов: они располагаются сразу после полей в порядке, зависящем от принимаемых ими числа аргументов — от меньшего к большему.

8. Значение примитивов (int, float, double и т. д.) копируются как есть. Ссылки на объекты типа immutable (например String), также копируются как есть. Несмотря на то, что оригинальный и порожденный объекты ссылаются на тот же самый адрес в памяти, immutable-объекты и никогда не будут изменяться.

9. Ссылки на mutable объекты (например Date, List и т. д.) должны копироваться при помощи глубокого копирования. Иначе оригинальный и порожденный объекты будут ссылаться на один и тот же адрес в памяти и соответственно, любые изменения объекта (оригинального или порожденного) будут отображаться на всех объектах.

10.     public BankAccount(BankAccount account) {
            customer = new Customer(account.customer.name); // !!!! глубокое копирование
            opened = LocalDateTime.now();
            balance = 0.0f;
        }

11.     public BankAccount(BankAccount account) {
            customer =  account.customer; // !!!!  неглубокое копирование
            opened = LocalDateTime.now();
            balance = 0.0f;
        }

////////////////ВОПРОСЫ//////////////
1
2. Какие классы счытываю и запысывают данные из массива байт?
3. Какой механизм чтения / записи у потоков?



