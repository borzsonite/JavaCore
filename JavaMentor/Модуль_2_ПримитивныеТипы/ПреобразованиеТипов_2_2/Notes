1. Автоматическое преобразование одних примитивных типов в другие возможно в случае преобразования менее емкого типа в более емкий, например: byte в short, int в long, float в double

2. При автоматическом преобразовании старшие разряды более широкого типа заполняются занаковым битом исходного значения.

3. Возможно автоматическое преобразование из целочисленного типа в вещественный, при этом возможна потеря точности.

4. При приведении более емкого типа к менее емкому, лишние старшие биты отбрасываются, например int a = 1024 (0100 0000 0000), поэтому byte b = (byte) a // 0, т.к старшие биты (0100) отбрасываются

5. При приведении вещественного числа к целочисленному (double --> int) дробная часть отбрасывается, округления не происходит.

6. При приведении слишком большого вещественного числа к целочисленному, получается максимальное значение числа целочисленного типа.

7. Слишком большой double при приведении к float превращается в бесконечность.

8. Автоматическое расширение это приведение двух операднов к одному типу при применении к ним бинарного оператора.

9. Правила автоматического расширения следующие: если один из операндов double, то оба приводятся к double. Иначе если один из операндов float, то оба приводятся к float. Иначе если один из операндов long, то оба приводятся к long. Иначе оба приводятся к int.

10. Из-за автоматического расширения при сложении двух переменных типа byte получится значение типа int, поэтому необходимо принудительное приведение byte b3 = (byte) (b1 + b2)

11. Для каждого примитивного типа есть класс обертка ссылочного типа имеющий такое же название, но начинающееся с большой буквы (кроме Integer, Character)

12. Классы обертки применяются для хранения чисел и символов в коллекциях, т.к. стандартные коллекции не поддерживают примитивы, или для указания отсутствия значения у переменной для этого можно примитив обернуть в класс-обертку и указывать для нее значение либо null либо ссылку на объект.

13. Для упаковки (boxing) примитивов в объекты используется метод valueOf().   Integer ref = Integer.valueOf(primitive); для распаковки (unboxing) используется метод intValue(), floatValue() etc. int primitive = ref.intValue();

14. Поддерживается неявный boxing/unboxing т.е. без явного использоваия методово valueOf() intValue(), например Integer a = 1; int b = a; вместо Integer a = Integer.valueOf(1), int b = a.intValue();

15. Над обертками можно выполнять арифметические операции как с примитивами, но это на порядок медленее, например Integer a = 1; Integer b = 2; Integer c = a + b;

16. У классов оберток есть метод parseInt("123") //123 - для парсинга примитива (числа) из строки, и метод toString() для  парсинга строки из числа Long.toString(123) // "123"

17. При конкатенации со строкой примитив превращается в строку, например sout("area " + 51) // area 51

18. У классов оберток есть много полезных методов, например: Integer.MAX_VALUE; // максимальное значение типа, Integer.bitCount(123); // количество единиц в двузначном представлении числа, Character.isLetter('a') // является ли символ буквой, Float.POSITIVE_INFINITY // возвращает Infinity,Double.NaN // возвращает NaN, Double.isNaN // возвращает является ли число не числом.

19. Автоматическое преобразование без потери точности:
    - short <-- byte
    - int <-- short
    - long <-- int
    - int <-- char
    - double <-- int
    - double <-- float
    Автоматическое преобразование с потерей точности:
    - float <-- int
    - float <-- long
    - double <-- long

20. Приведение типов это ситуация при которой возникает значение определенного типа, которое присваивается переменной другого типа.

21. Автоматическое расшрирение в выражениях служит для того чтобы результат этого выражение не превысил диапазон допускаемый самым широким типом.


    /////////////////////////////ВОПРОСЫ    /////////////////////////////
1. В каких случаях происходит автоматическое преобразование примитивных типов?
2. Что происходит со старшими разрядами более широго типа при автоматическом преобразовании?
3. Возможно ли автоматического преобразование целочисленного типа в вещественный, что при этом может произойти?
4. Что происходит при приведении более емкого типа к менее емкому?
5. Что происходит при приведении вещественного числа к целочисленном?
6. Что происходит при приведении слишком большого вещественного числа к целочисленному?
7. Что происходит при приведении слишком большого double к float?
8. Что такое автоматическое расширение?
9. Какое правило автоматического расширения?
10. Что произойдет при сложении двух переменных типа byte?
11. Что есть у каждого примитивного типа, и в чем его особенность?
12. Для чего нужны классы обертки?
13. Что такое boxing/unboxing c помощью каких методов он выполняется?
14. Что такое неявный boxing/unboxing
15. Можно ли выполнять над обертками арифметические операции как над примитивами, в чем различие такого применения?
16. Какие методы используются для парсинга числа из строки и наоборот?
17. В каких случаях примитив превратиться в строку без использования специального метода?
18. Какие полезные методы есть у классов оберток?
19. Преобразование каких типов происходит автоматически без потери точности, каких с потерей?
20. Что такое приведениет типов?

////////////////////ПОВТОРЫ//////////////////////
27.08.2020 +
28.08.2020 -
29.08.2020 +
31.08.2020+
04.09.2020
11.09.2020
25.09.2020
25.10.2020
