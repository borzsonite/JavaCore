1. Для успешного переопределения метода необходимы 4 условия:
    - метод производного класса должне иметь в точности такой же набор параметров что и у базового класса.
    - метод базового класса должен быть виден в производном классе
    - тип возвращаемый методом произодного класса должен совпадать или быть подтипом возвращаемым методм базового класса
    - метод производного класса должен иметь такой же или более открытый модификатор доступа чем у метода базового класса
2. Наследоваться можно только от одного класса.
3. Class2 extends Class 1. В  классе Class1 есть метод test1, в классе Class2 есть метод test2, имея экземпляр класса Class2 - class2 можно вызывать  на нем и собственные методы и методы родительского класса: class2.test2(); class2.test1();
4. Возможности базового класса можно расширять добавляя в классе наследнике собственные поля и методы
5. В классе наследнике можно переопределять методы определенные в родительском классе (переопределение метода - заведение в классе наследнике  метода с аналогичным названием и параметрами (сигнатурой), как в родительском классе, но с другой логикой выполнения. При этом значение,  возвращаемое переопределенным методом должно быть либо аналогичного типа, как у родительского класса, либо являтся его подклассом т.е. если в родителе - класс1 есть метод - Метод возвращающий значение типа класс1, в наследнике можно переопределить Метод чтобы он возвращал значение типа класс2 и это будет корректным т.к. класс2 является подклассом класса1, а также модификатор доступа у переопределенного метода должен быть либо тем же, либо более открытым.
6. Создание экземпляра класса наследника всегда включает в себя инициализацию базового класс т.е. вызов конструктора базового класса. При этом если у базового класса есть конструктор без параметров, такой конструктор вызовется в классе наследнике автоматически, но если необходимо вызвать конструктор базового класса с параметрами, это нужно будет сделать самостоятельно super(parametr). Вызов конструктора суперкласса долже быть перед любым другим кодом в конструкторе.
7. При наличии переопределенного в наследнике метода, существует возможность вызвать исходный метод супер-класса - super.overridedMethod()
8.  Слово super может использоваться только в теле класса наследника, если вызов переопределенного класса будет производится оператором класса наследника, всегда будет вызываться переопределенная версия из наследника.
9. Существуют требование относительно взаимодействия методов hashcode() и equals() - если объекты равны с точки зрения equals(), то у них должны быть одинаковые хэшкоды, поэтому нужно либо переопределять одновременно и equals() и hashcode() либо, не переопределять ни один.
10. В случа наличия суперкласса и наследника. Возможно такое присваивание Parent child = new Child(); при этом для объекта child, не доступны специфические методы класса Child, но  доступны методы определеные в Parent
11. Если есть объект типа Parent parent = new Parent, то приведение parent = child делается автоматически, обратное присваивание возможно только при явном приведении child = (Child)parent, например если класс Student extends Human, то
            Human human = new Human();
            Student student = new Student();
            human = student; // human более широкий тип и вмещает в себя в т.ч. студента
            student = (Student) human; // студент более узкий тип, не все люди студенты

12. Полиморфизм возможность иметь общий класс объединящий в себе свойства и методы одинаковые для его подкласса, например, класс Человек, подклассы: студент, преподаватель, врач, ученый. У супер-класса Человек могу быть поля и методы как  общие для всех подклассов -  имя, возраст, пол, так и уникальные для каждого подкласса, например у студента - размер стипендии, у ученого ученая степень, у врача его специализация. Общие методы могут быть переопределены в каждом конкретном подклассе (у каждого экземпляра ученного могут быть свои имя возраст и пол). Полиморфизм заключается в том,  что при вызове метода, являющегося общим для для весх подклассов и определенного в супер-классе, его реализация выплняется в зависимости от того на объекте какого класса был сделан вызов.


13. Помимо наследования существуют также композиция, когда объекты одного класса содержат объекты другого, например объект класса компьютре может содержать объекты классов жесткий диск, cdrom, монитор, клавиатура. Наследование следуте испольовать когда если можно сказать, что объект является дргим объектом, например студент является человеком, а композицию когда ответом является содержит, компьютер содержит жесткий диск.

14. Если в объявлении класса отсутствует слово extends, то такой класс наследутеся от класса Object

15. Все классы джава содержат методы объявленные в Object

16. Метод toString примененный к объекту возвращает полное имя_объекта@hashcode

17. Метод equals служит для сравнения содержимого объектов, если его не переопределить то от также сравнивает ссылки на объекты.

18. Метод equals переопределен у многих стандартных классов, у массивов НЕТ.

19. hash code это целочисленный (int) результат работы метода которому в качестве входного параметра передан объект.

20. Множество объектов мощнее множества хэшкодов, поэтому хэшкоды разных объектов могут совпадать, это называется коллизией.

21. Если хэшкоды разные, то объекты гарантировано разные, если хэшкоды равны то входные объекты не всегда равны.

22. Вероятность возникновения коллизии зависит от алгоритма генерации хэшкода.

23. Если объекты одинаковые, то и хэшкоды одинаковые, но не наоборот.

24. При проверке объектов на равенство сначала вызывается метод hashcode. Если хэшкоды разные то вызывать метод equals нет смысла т.к. ясно что объекты не равны.

25. Из-за того что одинаковость хэшкоде не гарантирует одиноковость объектов в случае равенства хэшкод, дополнительно вызывается equals, который со 100% вероятностью скажет одинаковые объекты или нет.

//////////////////////////////ВОПРОСЫ//////////////////////////////////
1. Какие 4 условия успешного переопределения метода?
2. От скольки классов можно унаследоваться?
3. Можно ли вызвать в экземпляре класса наследника поля и методы определенные в родителе?
4. Каким образом можно расширять возможности базового класса в классе наследнике?
5. Что такое переопределение метода, в чем его отличие от перегрузки?
6. Что обязательно включает в себя создание класса-наследника? Как осущетсвляется вызов конструктора суперкласса с параметрами из конструктора наследника? Какова особенность вызова конструктора супер-класса из конструктора наследника?
7. Как вызвать оригинальный метод супер-класса, переопределенный в наследнике?
8. Где может использоваться слово super при обращении к базововму классу?
9. Какие существуют требования относительно hashcode() при сравнении объектов посредством equals()?
10. В случае присванивания: Parent child = new Child(); какие методы доступны и не доступны экземпляру child?
11. Возможно ли автоматическое приведение child = parent?
12. В чем суть полиморфизма?
13. Что такое композиция? В каких случаях следует применять композицию, а в каких наследование?
14. От какого класса наследуется класс если в его определении не указано extends?
15. Какие методы одинаковы для всех классов?
16. Что возвращает не переопределенный метод toString примененный к объекту?
17. Для чего служит метод equals примененный к объектам? Что произойдет если использовать не переопределенный eaquals для сравнения объектов?
18. У какого станадртного класса метод equals не переопределен?
19. Что передается в качестве параметра методу hashcode, что он возвращает?
20. Почему происходит коллизия при сравнении объектов?
21. В каком случае объекты гарантировано разные, в каком возможно равны?
22. От чего зависит вероятность коллизии?
23. Верно ли что если объекты одинаковые то и хэшкоды тоже одинаковые, но не наоборот?
24. Какой метод вызывается первым в случае сверки двух обектов, почему если хэшкоды не равны вызывать метод equals не имеет смысла?
25. Почему даже при равенстве хэшкодов все равно вызывается метод equals?