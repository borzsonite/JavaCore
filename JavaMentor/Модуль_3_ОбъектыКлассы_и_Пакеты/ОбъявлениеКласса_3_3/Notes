1. Объявление класса состоить из слова class и его имени, для классов верхнего уровня может использоваться модификатор public, Если модификатора нет это означает доступ к классу на уровне пакета.
2. В случае если файл содержит несколько классов, модификатор public может быть только у одного класса и имя этого класса должно совпадать с имененм файла.
3. Если в объявлении класса присутствует слово final, это означает что от класса нельзя наследоваться.
4. Состояние экземпляра класса определяется значением его полей (переменных)
5. Объявление поля состоит из модификатора доступа, типа поля и его имени.
6. Если при объявлении поля его значение не указано, то оно будет инициализировано значением по умолчанию: 0, null, false
7. Поскольку в большинстве случаев, состояние экземпляра класса т.е. значания его полей являются деталью реализации, эти поля должны быть скрыты т.е. иметь модификатор private.
8.Классы должны взаимодействовать между собой с помощью методов, а не обращаться напрямую к состянию друг друга.
9. Модификатор final в объявлении поля означает, что значение ему можно присвоить только один раз и после этого менять это значение будет нельзя. Часто присвоение значения полю final делается через конструктор.
10. Конструктор класса вызывается в случае применения оператора new.
11. Объявление конструктора состоит из модификатора доступа и имени класса.
12. Если параметр конструктора имеет такое же имя как поле класса, то для доступа к полю класса в конструкторе используется префикс this.
13. this это ссылка на текущий объект в контексте которого выполняется конструктор или любой другой метод.
14. Если не указывать в классе свой конструктор, то при создании экземпляра будет вызван конструктор по умолчанию (без параметров)
15. Если необходимо запретить создание экземпляра класса, конструктор по умолчанию нужно сделать приватным.
16. Пример вызова конструктора из другого конструктора при помощи this.
 From within a constructor, you can also use the this keyword to call another constructor in the same class. Doing so is called an explicit constructor invocation. Here's another Rectangle class, with a different implementation from the one in the Objects section.

 public class Rectangle {
     private int x, y;
     private int width, height;

     public Rectangle() {
         this(0, 0, 1, 1);
     }
     public Rectangle(int width, int height) {
         this(0, 0, width, height);
     }
     public Rectangle(int x, int y, int width, int height) {
         this.x = x;
         this.y = y;
         this.width = width;
         this.height = height;
     }
     ...
 }
 This class contains a set of constructors. Each constructor initializes some or all of the rectangle's member variables. The constructors provide a default value for any member variable whose initial value is not provided by an argument. For example, the no-argument constructor creates a 1x1 Rectangle at coordinates 0,0. The two-argument constructor calls the four-argument constructor, passing in the width and height but always using the 0,0 coordinates. As before, the compiler determines which constructor to call, based on the number and the type of arguments.

 If present, the invocation of another constructor must be the first line in the constructor.

17. При помощи перегрузки конструкторов и вызова конструктора из конструктора возможно эмулировать задание в конструкторе значений полей по умолчанию.
18. Метод исполняется в контексте конкретного экземпляра класса, поэтому может обращаться к полям и методам этого класса.
19. Если у метода указан модификатор final это означает, что данный метод не может быть переопределен в классах наследниках.
20. За счет наличия в классе перегруженных методов (с одинаковым названием, но разными параметрами) возможно эмулировать вызов метода с параметрами по умолчанию. (видео 3.3_4_t0.56)
21. Статические поля и методы существуют независимо от экземпляров класса и могут вызываться по имени класса. Math.sqrt(4)
22. Статический метод исполняется в контексте класса, а не конкретного объекта, поэтому он не имеет доступа к нестатическим полям и методам и this.

 ///////////////////////////////////////ВЛОЖЕННЫЕ КЛАССЫ///////////////////////////////////
23. Вложенные классы (nested) бывают статическими и нестатическими. Нестатические классы называют внутренними (inner)
24. Внутренние классы подразделяются на локальные и анонимные
25. Объект внутреннего класса не можeт существовать без объекта внешнего класса. Пример кода, Bicycle внешний класс, Seat внутренний:
 public class Main {
    public static void main(String[] args) {
        Bicycle bicycle = new Bicycle("Peugeot", 120, 40); //объект внешнего класса
        Bicycle.Seat seat = bicycle.new Seat();//объект внутреннего класса
        seat.getSeatParam();
    }
 }

26. У объекта внутреннего класса есть доступ к полям внешнего класса. Доступ получается через следующую конструкцию: ИмяВнешнегоКласса.this.переменнаяВнешнегоКласса (Bicycle.this.seatPostDiameter). Также из внутреннего класса можно напрямую обращаться к полям внешнего класса по короткому имени.
27. Объект внутреннего класса нельзя создать в статическом методе внешнего класса
28. При создании объекта внутреннего класса в него передается ссылка на объект внешнего класса.
29. Внутренний класс не может содержать статические переменные и методы
30. У внутреннего класса может быть любой модификатор, при этом надо учитывать что от модификатора зависит место в котором можно будет создать объект внутреннего класса, например с модификатором public объект можно создавать везде
31. У внутреннего класса есть два this: 1- без префикса, ссылка на экземпляр внутреннего класса, 2- ИмяВнешнегоКласса.this ссылка на экземпляр внешнего класса. См. Car.java
32. Нестатические вложенные классы используются когда внешний класс является сложным объектом и логику его работы лучше представить как работу нескольких вложенных классов, которые являются неотьемлимыми частями единого целого (внешнего класса).
33. Нестатические вложенные классы обычно бывают приватными и их экземпляры создаются внутри методов внешнего класса.
34. Вложенные статические классы обычно делают публичными, они практически никак не связанны с внешним классом. Единственной связью является то, что вложенный статический класс имеет доступ к статическим полям внешнего класса. Также может быть какая то логическая связь.
35. Статические вложенные классы обычно используются извне, поэтому у них обычно модификатор доступа public
36. Создать объект вложенного статического класса можно следующим образом:
 Electrocar.Battery battery = new Electrocar.Battery();
37. Модификатор static имеет смысл только для вложенного класса


 ///////////////////////////////////ПЕРЕЧЕСЛЕНИЯ ENUM///////////////////////////////

38. enum по сути представляет собой класс с ограниченным количеством экземпляров.
39. enum может находиться как в отдельном файле (тогда он должен иметь модификатор public), так и внутри класса (тогда модификатор может быть private)
40. Объявление enum схоже с объявлением класса, только вместо слова class пишется слово enum. Объекты внутри enum пишуться БОЛЬШИМИ буквами, через запятую, в конце последнего ставиться точка с запятой.
41. Обратиться к объекту в enum можно укзав имя enum и через точку имя объекта: sout(Seasons.WINTER) // WINTER
42. У enum есть метод .values() возвращающий массив значений хранящихся в enum.
 public class Test {
     public static void main(String[] args) {
         for (Seasons s : Seasons.values()) {
             System.out.println(s); // WINTER, SPRING etc..
         }
     }
 }

43. enum удобны для использования в операторах switch, if.
 public class Test {
     public static void main(String[] args) {
         Seasons arg = Seasons.FALL;
          switch (arg)
         {
             case WINTER:
             System.out.println("It's winter! Christmas time!"); break;
             case SUMMER:
                 System.out.println("It's summer! Let's go to the beach!"); break;
             case SPRING:
                 System.out.println("It's spring! Easter is coming!"); break;
             case FALL:
                 System.out.println("It's fall! Helloween is coming!"); break;
         }
     }
 }

44. Методы enum:
 .name() // sout(Colors.RED.name()); // RED
 .ordinal() // sout(Colors.RED.ordinal()); // 0 if red is first element
 .equals() // sout(Colors.RED.equals(Colors.GREEN)) // false
 .hashcode() // sout(Colors.RED.hashcode()) // 54354141
 .toString() // sout(Colors.RED.toString()) // RED

45. Члены enum похожи на final static поля класса.
46. При создании enum он наследуется от класса Enum который, в свою очередь наследуется от Object, т.е. Object-->Enum-->MyEnum т.е. MyEnum instanceof Enum // true
47. В enum можно определять конструкторы. Если конструктор принимает параметры, эти параметры должны указываться при указании членов enum:
     private enum  Colors {
         RED("Красный"), //
         GREEN,
         BLUE;

         private String translation;

         Colors() { // пустой конструктор
         }

         Colors(String translation) { // конструктор с параметрами
             this.translation = translation;
         }

         private String getTranslation() {
             return translation; //Colors.RED.getTranslation() // Красный
         }

         @Override
         public String toString() {
             return translation;
         }
     }

/////////////////////////////////////ВОПРОСЫ//////////////////////////////////
1. Как выглядит объявления класса. Какие модификаторы доступа применимы к классам верхнего уровня, а какие к нижшего?
2. У скольки классов может быть модификатор public, если файл содержит несколько классов? С чем должно совпадать имя такого класса?
3. Что означает слово final в объявлении класса?
4. Чем определяется состояние экземпляра класса (объекта)?
5. Из чего состоит объявление поля?
6. Чем инициализируется поля, если его явно не указывать при объявлении?
7. Почему поля экземпрляра класса следует делать приватными?
8. Как должны взаимодействовать между собой классы? Что не должны делать классы при обращении друг к другу?
9. Что означает модификатор final в объявлении поля. Какой частый способ присвоения значения полю с final?
10. Что вызывается при применении оператора new?
11. Из чего состоит объявление конструтора?
12. Для чего используется слово this в конструкторе?
13. Что представляет из себя слово this в конструкторе?
14. Что произойдет если не прописать в классе свой конструктор?
15. Как можно запретить создание экземпляра класса?
16. Как можно вызвать конструктор из другого конструктора. Для чего это используется? Где должен находится вызов другого конструктора?
17. Что можно эмулировать путем вызова перегрузки конструктора и вызова конструктора из конструктора?
18. Может ли метод внутри класса обращаться к полям этого класса, почему так?
19. Что означает модификатор final в сигнатуре метода?
20. Что такое перегруженный метод, что можно эмулировать с помощью перегруженных методов?
21. От чего независят статические поля и методы, как можно вызвать статический метод, обратиться к статическому полую?
22. Почему статические методы не имеют доступ к нестатическим полям, методам, this?

///////////////////////////////////////ВЛОЖЕННЫЕ КЛАССЫ///////////////////////////////////
23. Какие есть две разновидности вложенных вложенных классов? как по английски обозначаются вложенные классы? Как еще называются нестатические вложенные классы?
24. На какие классы разделяются внутренние классы?
25. Без чего не может существовать объект внутреннего класса?
26. Как получить доступ к полям внешнего класса из объекта внутреннего класса?
27. Можно ли в статическом методе внешнего класса создать объект внутреннего класса?
28. Что передается в объект внутреннего класса при его создании?
29. Чего не может содержать внутренний класс?
30. Какие могут быть модификаторы у внутреннего класса? На что влияет модификатор внутреннего класса?
31. Какие два this есть у внутреннего класса?
32. Когда используются нестатические вложенные классы?
33. Какие модификаторы доступа обычно у вложенных нестатических классов и где создаются их экземпляры?
34. Какие модификаторы доступа обычно у вложенных статических классов. Как вложенные классы связаны  с внешними (две связи)?
35. Почему у вложенных статических классов модификатор доступа обычно public?
36. Как создать объект вложенного статического класса?
37. Для какого класса имеет смысл модификатор static в контесте вложенных классов?

///////////////////////////////////ПЕРЕЧИСЛЕНИЯ ENUM///////////////////////////////
38. Что по сути представляет из себя enum?
39. Где может находится enum и какие в зависимости от этого модификаторы у него могут быть?
40. Как объявляется enum и как записываются в него его члены?
41. Как можно обратиться к объекту в enum?
42. Какой метод возвращает массив значений хранящихся в enum?
43. Где удобно использовать enum?
44. Какие методы есть у enum?
45. На что похожи члены enum?
46. От чего наследуется экземпляр класса ENUM
47. Если конструктор ENUM принимает параметры, что нужно указать при указании членов ENUM?














