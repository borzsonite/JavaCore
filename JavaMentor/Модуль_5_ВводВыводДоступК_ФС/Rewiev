Перед ревью, проверьте себя по контрольным вопросам:

1) Что такое InputStream и OutputStream.
Это абстрактные файлы служат для абстрагирования различных способов ввода/вывода данных


2) На каком паттерне основана иерархия потоков ввода/вывода.
адаптер и декоратор.
Адапетр это объект, который трансформирует интерфейс или данные одного объекта так, чтобы они были понятны другому объекту. Адаптер имеет интерфейс, который совместим с одним из объектов, поэтому этот объект может свободно вызывать методы адапетра. Адаптер получает эти вызовы, преобразовывает их и перенаправляет второму объекту в понятном для него виде. При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы. Примеры InputStreamReader InputStreamWriter
Декоратор. Суть этого паттерна в том, что целевой объект помещается в объект обертку, который запускает базовое поведение целевого объекта и добавляет к нему что-то свое. Примеры BufferedReader, BufferedWriter

3) Отличие пакетов IO и NIO, InputStream от Reader.
IO - 1. потокоориентированный; 2. Блокирующий (синхронный) ввод/вывод
NIO - 1. Буфероринетированынй; 2. Неблокирующий ввод/вывод; 3. Селекторы
Поткооориентировнный ввод/вывод означает чтение/запись из потока поочередно. При этом невозможно произвольно двигаться по потоку вперед или назад.
Буфероориентированный - данные сначала считываются в буфер для последующей обработки. По буферу можно двигаться взад-вперед
Блокирующий ввод/вывод - когда в потоке выполнения вызывается метод read() write() происходит блокировка потока до тех пор пока не будет произведена запись или чтение.
Неблокирующий ввод/вывод позволяет испльзовать один поток выполнения для решения нескольких задач, вместо ожидания окончания чтения/записи
Селекторы позволяют одном потоку выполнения мониторить несколько каналов для ввода/вывода информации

4) как работает метод read?
.read() возвращает целочисленное представление следующего доступного байта в потоке. По достижении конца файла возвращает -1
.read(byte[] buffer) читает байты в buffer и возвращает количество прочитанных байт. По достижении конца файла возвращает -1
.read(byte[] buffer, int byteOffset, int byteCount) читает из потока в буфер, при этом данные из потока помещаются начинается с позиции заданной в offset, количестов считанных элементов == length

5) Как создать файл на компьютере с помощью java.
- 3 способа:
1. С помощью метода createNewFile класса File из паекта io
File file = new File("test.txt")
file.createNewFile();
2. C помощью потока:
FileOutputStream fos = new FileOutputStream("test.txt")
3. C помощью Классов Paths и  Files
Files.createFile(Paths.get("test8.txt"));

6) Как удалить директорию с файлами.
1. C помощью рекурсии и метода .delete() класса File паекта io

7)  Что такое сериализация и десериализация.
Сериализация процесс сохранения состояния объекта в последовательность байт
Десериализаиция процесс востановления объекта из последовательности байт.

8) Назовите несколько форматов сериализации.
JSON, BSON, YAML

9) Как сериализовать объект класса.
1. нужно чтоб класс имплементил интерфейс Serialazible.
FileOutputStream fos = new FileOutputStream("person.bin");
ObjectOutputStream oos = new ObjectOutputStream(fos);
oos.writeObject(obj);

10) Что делать, если одно из полей сериализовывать не нужно.
указать перед полем ключевое слово transient

11) Как сериализовать статическое поле.
использовать интерфейс Externalizable

12) Клонирование объекта. Глубокое и поверхностное.
- поверхностное клонирование с использованием метода clone(). При этом ссылочные поля оригинала и клона указывают на один и те же объекты.
- через конструктор (глубокое?) у оригинала создается конструктор, которому в качестве аргумента передается клонируемый объект и поля клона инициализируются полями оригинала.

Отдельно повтори разницу между serializable/externalizable (файнал поля, Статик поля, как работает, два метода переопределения и тд) и 4 способа копирования, два через clone, через конструктор и сериализацию

13) Что делает метод flush? Что делает метод close?
Очищает даные из буфера, перед очисткой записывает туда куда было определено.\
- flush() записывает содержимое буфера в место назначения и делает буфер пустым для дальнейшего хранения данных, но не закрывает поток окончательно. Это означает, что вы все еще можете записать в поток еще несколько данных.
- close() закрывает поток навсегда. Если вы хотите записать некоторые данные дальше,то вам нужно снова открыть поток и добавить данные к существующим.

14) Почему метод read() возвращает значение типа int, a не byte?
- Потому что он возвращает значения от 0 до 255, а чтобы иметь возможность вернуть -1 сделали тип возвращаемого значения int
??? почему read возвращает только положительные значения?

15) Отличие Scaner и BufferReader?
- Оба читают в буфер, но у Scaner - 1024, у BufferReader в 8 раз больше

1. Почему важно закрывать потоки?
Ответ, переполнение или утечка памяти практически не актуален,
Правильно, это поток будет занят и не позволит выполняться др...

2. Расскажи про классы Reader и Writer?
3. Как создать новый файл на жестком диске с помощью nio?
Если не ошибаюсь, ментор ответил createNewFile()... Пересмотрел док, просто File.write();

4. В чём отличие File от Path?
Почему Сканер медленее работает, чем БуферРидер?
Парсит строки на токены. Он же выделяет из потока разные токены в соответствии с типами
Чем отличается Serializable от Externalizable таким, что  ему не проблема final поля?
Externalizable должен иметь конструктор по умолчанию в отличие от serializable ибо там reflection api и констуктор не юзается - это отличие
А оставшиеся 10%, что рефлекшн апи позволяет создать объект не через конструктор, а через прямой доступ к членам класса и писать туда данные напрямую. Типа "хак" способ. В этом и разнится.

подробно просил рассказать о переопределенных методах read, раскрыть смысл аргументов каждого метода, что метод возвращает и почему возвращает значения типа int,  и/или -1

