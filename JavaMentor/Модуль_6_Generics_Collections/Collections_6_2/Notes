1. Коллекции могут запрещать изменять свое содержимое и предоставлять доступ только для чтения (в отличие от массивов)

2. Существуют коллекции специализированные для многопоточного использования.

3. Классы коллекций являются дженериками и парметризуются типом хранимых внутри элементов

4. Все коллекции работают только со ссылочными типами

5. Набор базовых методов коллекций определен в интерфейсе Collections

6. Для обхода коллекций используется iterator возвращаемый методом .iterator(), например:
Iterator<Integer> it  = collection.iterator(); где collection - это коллекция.
6.1 Методе .iterrator() применяется к коллекции см. 6.

7. Итератор имеет 3 метода:
- .hasNext() // проверка наличия следующего элемента
- .next() // получение следующего элемента
- .remove() // удаление текущего элемента. Текущим является последний возвращенный из .next() элемент.

8. Перед вызовом .next() нужно обязательно вызвать .hasNext() для проверки наличия следующего элемента.

9. Обход коллекции можно выполнить двумя способами, при помощи итератора и цикла foreach, например:

1.  Iterator<Integer> it = collection.iterator(); // Обход с помощью итератора
        while(it.hasNext()) {
            Integer element = it.next();
            Sout(element);
        }

2.  for(Integer element: collection) { // Обход с помощью foreach
        Sout(element)
    }

10. Если при обходе коллекции в нее необходимо внести изменения делать это нужно через итератор. Через collection.remove() нельзя.

11. List - простой список элементов проиндексированный от 0 до длины списка-1. Лист похож на массив - один и тот же элемент может встречаться под разными индексами.

12. ArrayList дает максимально дешевый доступ к элементу по индексу. Добавление или удаление элементов не такое дешевое тк. может приводить к переопределению массива или сдвигу элементов.

13. LinkedList основан на двусвязанных списках позволяет эффективно добавлять и удалять элементы в начало и конец списка. Но доступ по индексу n дороже т.к необходимо сделать n прыжков от начала списка.
13.1 В сравнении с ArrayList добавление и удаление элементов в LinkedList эффективнее, поскольку происходит за счет переопределения ссылок на ноды (prev, next)

14. При объявлении переменной лучше использовать название интерфейса, а указание класса производить в месте создания экземпляра: List<Integer> list = new ArrayList<>();

15. Еще одна интерфейс коллекций Queue. Элементы добавляются с хвоста и извлекаются с головы очереди (FIFO)

16. Методы Queue:
    boolean .add(E e) // Доавляет элемент в хвост очереди Если коллекция имеет конечный размер и он достигнут - throws exceptiion
    boolean .offer // // Доавляет элемент в хвост очереди Если коллекция имеет конечный размер и он достигнут - возвращает faulse

    E remove() // извлекают первый элемент из головы очереди. Если очередь пуста  - throws exceptiion
    E poll() // извлекают первый элемент из головы очереди. Если очередь пуста  - возвращает null

    E element() // позволяют посмотреть элемент в голове очереди не удаляя его. Если очередь пуста  - throws exceptiion
    E peek() // позволяют посмотреть элемент в голове очереди не удаляя его. Если очередь пуста  - возвращает null

17. Наследник Queue - интерфейс Deque. Отличается от Queue тем, что добавлять и удалять элементы можно  и с головы и с хвоста. Поэтому количество методов удваивается
    void addFirst(E e)
    void addLast(E e)

    boolean offerFirst(E e)
    boolean offerLast(E e)

    E removeFirst()
    E removeLast()

18. У Deque 2 реализации: ArrayDeque<> и  LinkedList<>

19. Четвертый элемент коллекций - ассоциативный массив Map<K,V>

20. Map позволяет идексировать элементы произвольными объектами.

21. Дубликаты ключей в Map не допускаются.

22. Основные методы Map
    int size() // количество элементов
    boolean isEmpty()
    boolean containsKey(Object key)
    boolean containsValue(Object value)
    V get(Object key) // получить значение по ключу
    V put(K key, V value) // сохранить значение по ключу
    V remove(Object key) //удалить пару ключ-значение
    void clear() //очисстить мапу

    Обход мапы:
    Set<K> keySet() // возвращает множество ключей
    Collection <V> values() //возвращает коллекцию значений
    .entrySet() //возвращает ключ-значение

23. Реалиазции интерфейса Map: HashMap, LinkedHashMap, TreeMap, аналогичные реализации интерфейса Set

24. Set хранит тольк уникальные значения

25. Реализации: HashSet - основан на реализации хэш-таблицы. Метод hashcode используется для определения ячейки хэштаблицы куда необходимо полжить объект. Метод equals используется для сравнения с элементом лежащим в этой ячейке хэштаблицы.

26 equals и hashcode должны быть согласованы те. если a.equals(b), то a.hashcode == b.hashcode иначе будут проблемы с нахождением элментов в хэштаблице.

27. Поля объекта влияющие на вычесление equals и hashcode во время нахождения в hashset не должны меняться. Если поля все таки нужн изменить, то нужно сначала удалить объект из таблицы поменять поля и затем добавить в set снова в новую ячейку хэштаблицы.

28. Порядок обхода HashSet при помощи итератора зависит от хэшкода и может выглядеть случайным. Для того чтобы обходить элементы в порядке из добавления нужно использовать LinkedHashSet

29. Интерфейс SortedSet поддерживает обход итератором в порядке возрастания элементов. Его реализация класс TreeSet<>

30. Методы SortedSet:
    SortedSet<E> headSet(E toElement) // возвращает подмножество элементов меньшее чем переданыый параметр
    SortedSet<E> tailSet(E fromElement) // возвращает подмножество элементов большее чем переданыый параметр
    SortedSet<E> subSet(E fromElement, E toElement)// возвращает подмножество элементов между передаными параметрами
    E first() //наименьший элемент
    E last() // наибольший элемент

31. Для сравнения элментов внутри TreeSet эти элементы либо должны реализовывать интерфейс Comparable c методом .compareTo(), либо в конструктор TreeSet должен передаваться экземпляр Comparator'a c методом .compare(par1, par2)

32. При работе с коллекциями удобно использовать утилитный класс Collections, который содержит много удобных методов, например .shuffle(list) перемешать элементы, .sort(list)

33. В классе Collections есть методы начинающиеся на unmodifiable позволяющие создать копию оригинальной колекции дооступную только для чтения, например
Set<String> set = Collections.unmodifiableSet(originalSet)
set.remove("abc") // trows exception
Это служит для защиты коллекции при передаче ее в какой-то метод.

34. У интерфейса Collection есть метод .toArray(list) возвращающий коллекцию экземпляров типа Object
List<Integer> list = ...
Object[] objects = list.toArray(); // Object потому что внутри параметризованного класса(??) нельзя получить экземпляр или массив типа указанного в качестве дженерика. Чтобы получить массив нужного типа нужно воспользоваться перегруженным вариантом метода toArray() который в параметрах принимает массив нужного типа:
Integer[] arr = list.toArray(new Integer[list.size()])

35. Конвертация из массива в коллекцию производится с помощью методов класса Arrays, например:
String[] arr = {"A", "B", "C"};
Set<String> s1 = new HashSet<>(Arrays.asList(arr))
или
Set<String> s2 = new HashSet<>(); // создать пустую коллекцию
Collections.addAll(s2, arr) // при помощи утилитного метода добавить в коллекцию все элементы массива.

36. При создании экземпляра map в параметрах в левой части необходимо указать типы ключа и значения:
Map<Integer, String> map = new HashMap<>();

37. Методы map:
    .put(K,V) // положить пару в map
    .get(K) // получить значение по значению ключа

38. В map не может быть дубликатов ключей, если в нее помещается пара с существующим ключом старая пара затирается.

39. Для обхода мапы используется следующая конструкция:
        for(Map.Entry<Integer, String> elem: map.entrySet()) {
            System.out.println(elem.getKey() + ":" + elem.getValue());
        }

40. HashMap НЕ поддерживает соответветсвие порядка помещения элементов и порядка их вывода.

41. Если необходимо чтобы элементы хранились в том порядке в котором помещялись нужно использовать LinkedHashMap or TreeMap. Последний поддерживает сортировку по ключу.

42. Порядок обхода и вывода элеметов в HashMap зависит от хэша и может выглядеть случайным.

43. Различия между HashMap, LinkedHashMap и TreeMap в том, что 1й не гарантирует порядок ввода/вывода, 2й гарантирует, 3й гарантирует + добавляется возможность сортировки по ключу

44. HashSet реализован на основе HashMap

45. Map реализован как массив LinkedLists

46. Для определения в какой индекс поместить значение в Map выполняется следующая последовательность:
 - на основе ключа (который является объектом)вычесляется hash (путем вызова метода .hashcode())
 - затем с hash'em выполняется побитовое умножение на (n-1) i.e index = hash & (n - 1). Эта операция гарантировано возвращает число от 0 до 15. По сути вычисляется остаток от целочисленного деления hash % (n - 1)
- далее значение помещается в ячейку с нужным индексом
- если индексы совпадают то значение добавляется как LinkedList, i.e создается ссылка на элемент

47. Высокая скорость в Map достигается за счет того, что для доступа к элементу не нужно проходится по всем узлам Map, нужный индекс вычесляется на основе хэшзначения

48. При поиске значения в Map сначала сравнивается хэш, затем сами значения путем вызова equals

49. Обхекты помещенные в TreeSet сорртируются порядком по умполчанию






///////////////////////////////////ВОПРОСЫ///////////////////////////////////
1. Могут ли коллекции запрещать изменение содержащихся внутри элементов?
2. Существуют ли коллекции для многопоточного использования?
3. Каким типом праметризуются коллекции?
4. С какими типами данных работают коллекции?
5. В каком интерфейсе определен базовый набор методов коллекций.
6. Что используется для обхода коллекций, что делает метод .iterrator() ?
6.1 К чему применяется метод .iterrator()
7. Какие методы имеются у итератора (назови 3).
8. Что нужно сделать перед вызововм .next()?
9. Какие два способа обхода коллекций?
10. Как можно правильно изменять коллекцию при обходе?
11. Что представляет из себя List, в чем сходство с массивом?
12. Какие преимущества и недостатки у ArrayList'a?
13. На чем основан LinkedList, в чем его преимущества и недостаки?
14. На что лучше ссылать переменную указывающую на коллекцию? Где следует производить указание класса?
15. Что такое Queue? как реализована и как работает?
16. Разница между методами add и offer
16. Разница между remove и poll?
16. Разница между элементами element и peek?
17. Что такое Deque?
17. Различия Queue и Deque
18. Реализации Класса Deque
19. 4й элемент коллекций?
20. Чем можно индексировать элементы в Map?
21. Возможны ли дубликаты ключей в Map?
22. Основные методы Map?
23. Реализации интерфейста Map?
24. Допускается ли хранение в Set дублирующихся значений?
25. На чем основана реализация HashSet, для чего используется метод hashcode? Для чего используется метод equals?
26. Что можно сказать относительно взаимодействия между hashcode и equals применительно к Set?
27. Можно ли менять поля объекта влияющие на вычесление hashcode и equals в HashSet? Как можно менять эти поля?
28. Каким будет порядок обхода элементов итератором в HashSet? От чего он зависит? Какую коллекцию следует использовать при необходимости обхода элементов в порядке их добавления?
29. Какой интерфейс поддерживает обход элементов в порядке возрастания? Назови его реализацию.
30. Основные методы SortedSet?
31. Какие условия должны выполнятся для возможности сравнения элементов внутри TreeSet?
32. Какой утилитный класс удобно использовать для работы с коллекциями? Назови несколько его методов.
33. Что позволяют делать методы интерфейса Collections с перфиксом unmodifiable?
34. Что делает метод toArray() применительно к коллекции? Почему у возвращаемого значения тип Object?
35. Какой можно конвертировать массив в коллекцию?
36. Что необходимо указать при создании экземпрляра Map в левой части выражения в параметрах <>?
37. Какие методы используются чтобы положить пару в Map? Получить значение по ключу?
38. Могут ли в Map быть дубликаты ключей? Что произойдет если попытаться добавить пару с существующим ключом?
39. Как можно обойти Map?
40. Поддерживается ли в HashMap порядок вывода элементов?
41. Какие классы поддерживают порядок вывода элементов? Какие сортировку по ключу?
42. Каков порядко обхода и вывода элементов в HashMap?


