Обратите внимание, что класс MailService ведет себя как Consumer, что общего у MailMessage и Salary и, как реализовать одинаковое поведение MailService относительно их. Имейте в виду, что map.get(null).equals(List<T>)  в ассертах вызовет NullPointerException, значит он тоже требует переопределения. Примечательно, что внутри одного из переопределяемых методов должно быть обращение к одноименному родительскому методу.. Всем Удачи, я закончил..

@Николай_Надеин, может, пишу уже для мёртвых, но всё таки. Почтовому сервису необходимо использовать методы Sendable, используя Consumer<Sendable<T>> мы даём ему такую возможность, ведь все принимаемые объекты реализуют Sendable. А используя просто Consumer<T> о принимаемом объекте ничего неизвестно.

Помогите, пожалуйста, с последней задачей! Правильно ли я понял? MailService делаем дженериком, который имплементирует Consumer<Sendable<T>> ? Внутри переопределен accept(), который принимает объекты MailMessage и Salary, по данным которых заполняет свой Map mailBox? А метод getMailBox выдает информацию по этому mailBox ? Или меня вообще не туда занесло?

лично я делала так, как вы написали :) Только принимает (accept) не конкретно "объекты MailMessage и Salary ", а объект  Sendable<T> (но по-другому у вас и не выйдет, ведь не зря же вы указали его как тип Consumer) :)

что мы знаем про mailbox? Смотрим в задание - он зависит от того как мы задали MailService:
MailService<Integer> или MailService<String>
Map<String, List<Integer>> salaries
Map<String, List<String>> mailBox
Видите связь между типом МейлСервис<T> и типом List<T>? Значит наш Мар будет не Map<String, List<String>>, а Map<String, List<T>>.
Теперь об интерфейсе - пересмотрите видео лекции еще раз на эту тему. Интерфейс позволяет реализовать полиморфизм.
Вот наш МейлСервис в accept принимает объект accept(Sendable<T> sendable), и что вы хотите с ним дальше сделать? (Будь то Salary или MailMessage - неважно) достать из объекта получателя и достюать из объект контент, да? чтоб положить их в Map<String, List<T>>. Вот и сделайте такой интерфейс с двумя этими методами, чтоб среда знала - раз у нас есть объект Sendable, то два этих метода у него точно будут.
Тем более и названия методов уже даже в задании подсказаны:
firstMessage.getTo()...
firstMessage.getContent()...
salary1.getTo()...
А чтоб и письма и зарплату можно было рассматривать как объект Sendable - мы применяем этот интерфейс к их классу. Тогда объекты этого класса будут еще и объектами этого Интерфейса.