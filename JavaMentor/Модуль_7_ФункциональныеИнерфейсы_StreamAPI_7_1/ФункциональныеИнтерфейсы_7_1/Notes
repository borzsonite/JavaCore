1. Функциональные интерфейсы содержат только один абстрактый метод, при этом дефолт и статические методы не в счет, их может быть сколько угодно (как и статических переменных)

2. Лямбда выражение - компактный синтаксис для передачи куска кода, в качестве парметра, в другой код.

3. Функциональное программирование это последовательное применение функций к некоторым значениям и др. функциям.

4. Стандартные интерфейсы находятся в пакете java.util.function

5. Существует 5 семейств функциональных интерфейсов:
    - Consumer<T> , которые принимают какое-то значение, но ничего не возвращают взамен

        @FunctionalInterface
        public Interface Consumer<T> {
            void accept(T t); // Принимает дженирализованый параметр <T> и ничего не возвращает (void)
        }

6. Существуют также интерфейсы IntConsumer, DoubleConsumer, LongConsumer принимающие значения соответствующих типов

7. Есть также интерфейс BiConsumer, принимающий 2 параметра и тоже ничего не возвращающий.

    @FunctionalInterface
    public interface BiConsumer<T, U> {
    void accept(T t, U u);
    }

8. Второе семейство Supplier<T>, ничего не принимает, а только возвращает

    @FunctionalInterface
    public interface Supplier<T> {
        T get(); //
    }

9. Существуют также интерфейсы BooleanSupplier,  IntSupplier, DoubleSupplier, LongSupplier возвращающие значения соответствующих типов

10. Третье семейство Predicate (предикаты), принимающие какое-то значение, а возвращающие значение булевского типа.

    @FunctionalInterface
    public interface Predicate<T> {
        boolean test(T t); // возвращает boolean, принимает Т
    }

11. Существуют предикаты IntPredicat, LongPredicate, DoublePredicate

12. Существует предикат принимающий 2 параметра

    @FunctionalInterface
    public interface BiPredicate<T, V> {
        boolean test(T t); // возвращает boolean, принимает Т
    }

13. Четвертое семейство Functions, принимающие аргумент и возвращающие значение какого-то типа. В общем случае это значения разных типов.

    @FunctionalInterface
    public interface Function<T, R> {
    R apply(T t);
    }

14. BiFunction - функция принимающая два параметра.

15. Существует несколько разновидностей функций, например принимающая double -> возвращающая объект (doubleFunction); принимающая long-> возвращающая int (LongToIntFunction); принимающая объект -> возвращающая int(ToIntFunction)

16. Пятое смейство Operator, частный случай Function принимающий и возвращающий значения одного типа.

17. UnaryOperator принимает один парметр, BinaryOperator - два параметра. Унарные и бинарные операторы заведены для операциями на Int, Long, Double (IntUnaryOperator, LongBinaryOperator etc.

18. Инстанцировать функциональный интерфейс можно 3мя способами:
    - создать класс имплементирующий ФИ
    - использовать лямбда-выражение:

        IntUnaryOperator square x -> {
        return x * x
        }
        или
        IntUnaryOperator square x -> x * x // Если выражение состоить из одной строки и не содержит return, то фигурные скобки можно не писать.
        }

19. Внутри лямбды можно обращаться к полям класса и метода в котором объявлена лямбда. В случае с методом переменные дложны быть final (хотя можно это не указывать)

20.  Из лямбды нельзя менять значения переменных в методе внутри которого была объявлена лямбда. Чтобы обойти это требование внутри метода можно создать массив из одного элемента и менять его значение (т.к. переменная массива является финальной 7.1.13- t2.20)

21. Третий способ инстанцировать ФИ - при помощи ссылки на метод, возможно несколько вариантов:
    - Можно сослаться на статический метод, указав имя_класса::имя_метода, например:
    ToIntFunction<String> intParser = Integer::parseInt;

    - Можно сослаться на НЕстатический метод, указав имяКласса.ИмяОбъекта::имя_неСтатическогоМетода, например:
    Consumer<Object> printer = System.out::println;

     - Также можно сослаться на НЕстатический метод, указав имяКласса::имя_неСтатическогоМетода, например:
     Function<Object, String> objectToString = Object::toString; // не статический метод будет вызван на объекте, указанного в качестве первого парметра

     - Можжно ссылаться на конструктор:
     IntFunction<String[]> arrayAllocator = String[]::new;

22. Использовать ФИ Consumer можно 3-мя способами:
    1. Создавая класс имплементрующий Consumer и передавая его объект в метод
    2. С помощью анонимного класса
    3. С помощью лямбда выражения.

Пример:
public class ConsumerExample {

    static class ConsumerEx implements Consumer<Integer> { // создаем класс Consumer
        @Override
        public void accept(Integer integer) { // в котором переопределяем метод accept
            System.out.println(integer); // прописываем логику
        }
    }

    public static void main(String[] args) {
        List<Integer> list = Arrays.asList(1,2,3,4,5);

        // далее 3 варинта использоваия Consumer'a
        System.out.println("=====================var 1==================");
        ConsumerEx ex = new ConsumerEx(); // 1. Создать экземпляр класса
        list.forEach(ex); // и передать его в качестве парметра в метод

        System.out.println("=====================var 2==================");
        list.forEach(new Consumer<Integer>() { // 2. В методе прописать анонимный класс реализующий Consumer'a
            @Override
            public void accept(Integer integer) {
                System.out.println(integer); // в котором переопеделить метод accept
            }
        });

        System.out.println("=====================var 3==================");
        list.forEach(integer -> System.out.println(integer)); // 3. заменить анонимный класс реализующиий ФИ на лямбду.
    }
}

23. Типы параметров в лямбда выражении должны соответствовать типам парметров ФИ.

24. Нетерминальное ЛВ возвращает какое-либо значение, терминальное ЛВ вызвращает.

///////////////////////////ВОПРОСЫ//////////////////////
1. Определенние ФИ, может ли в ФИ быть больше одного дефолт и статического метода (переменных)?
2. Определение лябмбда выражения.
3. Определения функционального программирования.
4. В каком пакете нахдятся стандартные интерфейсы?
5. Сколько существует семейств ФИ? Что делает ФИ Consumer<T>?
6. Какие ФИ входят в семейство Consumer?
7. Как называется ФИ принимающий 2 параметра и ничего не возвращающий?
8. Что делают ФИ Supplier<T>?
9. Какие ФИ входят в семейство Supplier<T>?
10. Что делают ФИ Predicate<T>?
11. Какие ФИ входят в семейство Predicate<T>?
12. Как называется ФИ принимающий 2 параметра и возвращающий булевское значение?
13. Как называется ФИ принимающий аргумент и возвращающий значение каког-либо типа? К каким типа в общем случае относятся аргумент и возвращаемое значение?
14. Как называется ФИ принимающий два аргумента?
15. Как называются разновидности ФИ Function<T>  принимающая double -> возвращающая объект? принимающая long-> возвращающая int? принимающая объект -> возвращающая int?
16. Как назыается ФИ (частный случай Funciton<T>) принимающий и возвращающий значения одного типа?
17. Как называется опретор принимающий один (два) параметра? Какие унарные (бинарные) операторы заведены для операций над int, long, double?
18. Как можно инстанцировать ФИ (3 способа)?
19. Можно ли внутри лямбды обращаться к полям класса и метода в котором объявлена лямбда. Какое условие для переменных метода?
20. Можно ли из лямбды менять значения переменных в методе внутри которого была объявлена лямбда? Как это обойти?
21. Какой  3-й способ инстанцировать ФИ? Какие у него подварианты?
22.

